diff --git a/deps/v8/src/json/json-stringifier.cc b/deps/v8/src/json/json-stringifier.cc
index 30dfb25623..e52d4e0067 100644
--- a/deps/v8/src/json/json-stringifier.cc
+++ b/deps/v8/src/json/json-stringifier.cc
@@ -26,7 +26,7 @@ namespace internal {
 
 class JsonStringifier {
  public:
-  explicit JsonStringifier(Isolate* isolate);
+  explicit JsonStringifier(Isolate* isolate, bool optimized=false);
 
   ~JsonStringifier() {
     if (one_byte_ptr_ != one_byte_array_) delete[] one_byte_ptr_;
@@ -253,6 +253,11 @@ class JsonStringifier {
       cursor_ += length;
     }
 
+    V8_INLINE void AppendPacked(uint64_t packed) requires(sizeof(DestChar) == sizeof(uint8_t)) {
+      MemCopy(cursor_, &packed, 8);
+      cursor_ += 8;
+    }
+
    private:
     int* current_index_;
     DestChar* start_;
@@ -326,13 +331,26 @@ class JsonStringifier {
   // Returns whether any escape sequences were used.
   template <typename SrcChar, typename DestChar, bool raw_json>
   V8_INLINE static bool SerializeStringUnchecked_(
-      base::Vector<const SrcChar> src, NoExtendBuilder<DestChar>* dest);
+      base::Vector<const SrcChar> src, NoExtendBuilder<DestChar>* dest,
+      int offset=-1, int endOffset=-1);
+
+  // uses SIMD with a register approach to check if string needs escaping 
+  // much faster perf than memory lookup, falls back to calling 
+  // SerializeStringUnchecked_ when some chars within a block need escaping
+  template <typename SrcChar, typename DestChar, bool raw_json>
+  V8_INLINE static bool SerializeStringUncheckedSWAR_(
+      base::Vector<const SrcChar> src, NoExtendBuilder<DestChar>* dest,
+      int offset, int endOffset);
 
   // Returns whether any escape sequences were used.
   template <typename SrcChar, typename DestChar, bool raw_json>
-  V8_INLINE bool SerializeString_(Tagged<String> string,
+  V8_INLINE bool SerializeStringOptimized_(Tagged<String> string,
                                   const DisallowGarbageCollection& no_gc);
 
+  // Returns whether any escape sequences were used.
+  template <typename SrcChar, typename DestChar, bool raw_json>
+  V8_INLINE bool SerializeString_(Tagged<String> string,
+                                  const DisallowGarbageCollection& no_gc);
   // Tries to do fast-path serialization for a property key, and returns whether
   // it was successful.
   template <typename DestChar>
@@ -342,6 +360,32 @@ class JsonStringifier {
   template <typename Char>
   V8_INLINE static bool DoNotEscape(Char c);
 
+  // inspired by v8 changes, but extended to 64 bit
+  // https://github.com/v8/v8/blob/main/src/json/json-stringifier.cc#L522
+  V8_INLINE static bool NeedsEscape(uint64_t input) {
+    constexpr uint64_t mask_0x20 = 0x2020202020202020ull;
+    constexpr uint64_t mask_0x22 = 0x2222222222222222ull;
+    constexpr uint64_t mask_0x5c = 0x5C5C5C5C5C5C5C5Cull;
+    constexpr uint64_t mask_0x01 = 0x0101010101010101ull;
+    constexpr uint64_t mask_msb  = 0x8080808080808080ull;
+    // Escape control characters (< 0x20).
+    const uint64_t has_lt_0x20 = input - mask_0x20;
+    // Escape double quotation mark (0x22).
+    const uint64_t has_0x22 = (input ^ mask_0x22) - mask_0x01;
+    // Escape backslash (0x5C).
+    const uint64_t has_0x5c = (input ^ mask_0x5c) - mask_0x01;
+    // Chars >= 0x7F don't need escaping.
+    const uint64_t result_mask = ~input & mask_msb;
+    const uint64_t result = ((has_lt_0x20 | has_0x22 | has_0x5c) & result_mask);
+    return result != 0;
+  }
+
+  // estimates the maximum number of chars that can fit in the remaining buffer
+  // assumes worst case scenario: each char is convereted in to 6
+  V8_INLINE int MaxCharsThatFit() {
+    return (part_length_ - current_index_) / 6;
+  }
+
   V8_INLINE void NewLine();
   V8_NOINLINE void NewLineOutline();
   V8_INLINE void Indent() { indent_++; }
@@ -386,6 +430,7 @@ class JsonStringifier {
   int stack_nesting_level_;
   bool overflowed_;
   bool need_stack_;
+  bool optimize_serialize_str_;
 
   using KeyObject = std::pair<Handle<Object>, Handle<Object>>;
   std::vector<KeyObject> stack_;
@@ -400,7 +445,14 @@ class JsonStringifier {
 
 MaybeHandle<Object> JsonStringify(Isolate* isolate, Handle<Object> object,
                                   Handle<Object> replacer, Handle<Object> gap) {
-  JsonStringifier stringifier(isolate);
+  // get JSON._use_original_stringify flag to control use optimized codepath
+  Handle<Object> original_stringify = JSObject::GetProperty(
+    isolate,
+    handle(isolate->native_context()->json_object(), isolate),
+    "_use_original_stringify"
+  ).ToHandleChecked();
+
+  JsonStringifier stringifier(isolate, IsUndefined(*original_stringify, isolate));
   return stringifier.Stringify(object, replacer, gap);
 }
 
@@ -446,7 +498,7 @@ const bool JsonStringifier::JsonDoNotEscapeFlagTable[] = {
     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 };
 
-JsonStringifier::JsonStringifier(Isolate* isolate)
+JsonStringifier::JsonStringifier(Isolate* isolate, bool optimized)
     : isolate_(isolate),
       encoding_(String::ONE_BYTE_ENCODING),
       gap_(nullptr),
@@ -457,6 +509,7 @@ JsonStringifier::JsonStringifier(Isolate* isolate)
       stack_nesting_level_(0),
       overflowed_(false),
       need_stack_(false),
+      optimize_serialize_str_(optimized),
       stack_(),
       key_cache_(isolate) {
   one_byte_ptr_ = one_byte_array_;
@@ -1367,14 +1420,75 @@ JsonStringifier::Result JsonStringifier::SerializeJSProxy(
   return SUCCESS;
 }
 
+template <typename SrcChar, typename DestChar, bool raw_json>
+bool JsonStringifier::SerializeStringUncheckedSWAR_(
+    base::Vector<const SrcChar> src, NoExtendBuilder<DestChar>* dest,
+    int offset, int endOffset) {
+  // Assert that base::uc16 character is not truncated down to 8 bit.
+  // The <base::uc16, char> version of this method must not be called.
+  DCHECK(sizeof(DestChar) >= sizeof(SrcChar));
+
+  // don't do SWAR for short strings
+  if (endOffset - offset < 8) {
+    return SerializeStringUnchecked_<SrcChar, DestChar, raw_json>(src, dest, offset, endOffset);
+  }
+
+  int i = offset;
+  bool required_escaping = false;
+  // can only do SWAR iff both src and dest use single byte chars
+  // process the string 8 chars/bytes at a time and use bitwise operations
+  // to check if any of the 8 need escaping. If they don't copy them over
+  // otherwise, fallback on the char-by-char function, for these 8 chars
+  if constexpr ((sizeof(SrcChar) == 1 && sizeof(DestChar) == 1)) {
+    using PackedT = uint64_t;
+    const SrcChar* chars = &src[i];
+    const SrcChar* src_begin = src.begin();
+
+    // get to 8 byte aligned address, process all the bytes before one by one
+    uintptr_t chars_addr = reinterpret_cast<uintptr_t>(chars);
+    uintptr_t addr_offset = chars_addr & 0x07;
+    if(addr_offset != 0) {
+      const int bytesToWrite = 8 - addr_offset;
+      required_escaping = SerializeStringUnchecked_<SrcChar, DestChar, raw_json>(src, dest, i, i+bytesToWrite);
+      i += bytesToWrite;
+    }
+
+    // now chars[i] points to an 8 byte aligned address
+    for (; i < endOffset - 7; i+=8) {
+      PackedT packed = *reinterpret_cast<const PackedT*>(src_begin + i);
+      if (V8_LIKELY(raw_json || !NeedsEscape(packed))) {
+        dest->AppendPacked(packed);
+      } else {
+        required_escaping = true;
+        SerializeStringUnchecked_<SrcChar, DestChar, raw_json>(src, dest, i, i+8);
+      }
+    }
+  }
+
+  // serialize any chars that weren't picked up by packed/swar method above
+  if (i < endOffset){
+    required_escaping = SerializeStringUnchecked_<SrcChar, DestChar, raw_json>(src, dest, i, endOffset) || required_escaping;
+  }
+  return required_escaping;
+}
+
+
 template <typename SrcChar, typename DestChar, bool raw_json>
 bool JsonStringifier::SerializeStringUnchecked_(
-    base::Vector<const SrcChar> src, NoExtendBuilder<DestChar>* dest) {
+    base::Vector<const SrcChar> src, NoExtendBuilder<DestChar>* dest,
+    int offset, int endOffset) {
   // Assert that base::uc16 character is not truncated down to 8 bit.
   // The <base::uc16, char> version of this method must not be called.
   DCHECK(sizeof(DestChar) >= sizeof(SrcChar));
   bool required_escaping = false;
-  for (int i = 0; i < src.length(); i++) {
+
+  // default behavior ...
+  if(offset == -1 && endOffset == -1) {
+    offset = 0;
+    endOffset = src.length();
+  }
+
+  for (int i = offset; i < endOffset; i++) {
     SrcChar c = src[i];
     if (raw_json || DoNotEscape(c)) {
       dest->Append(c);
@@ -1385,7 +1499,7 @@ bool JsonStringifier::SerializeStringUnchecked_(
       required_escaping = true;
       if (c <= 0xDBFF) {
         // The current character is a leading surrogate.
-        if (i + 1 < src.length()) {
+        if (i + 1 < endOffset) {
           // There is a next character.
           SrcChar next = src[i + 1];
           if (base::IsInRange(next, static_cast<SrcChar>(0xDC00),
@@ -1430,6 +1544,46 @@ bool JsonStringifier::SerializeStringUnchecked_(
   return required_escaping;
 }
 
+template <typename SrcChar, typename DestChar, bool raw_json>
+bool JsonStringifier::SerializeStringOptimized_(Tagged<String> string,
+                                       const DisallowGarbageCollection& no_gc) {
+  bool required_escaping = false;
+  if (!raw_json) Append<uint8_t, DestChar>('"');
+
+  // serialize the contents of the string by in chunks of chars that can fit in
+  // the available buffer, extend the buffer only once full. Note that we need to
+  // be conservative in the number of chars needed, eventhough in real life the
+  // number of chars written out will be the ~ same as the number of chars in the
+  // string. For example, if we have a buffer of 600 bytes available we can only
+  // safely write 100 chars. If we have a string of 200 chars that needs no escaping
+  // then we can safely write it in chunks:
+  // chunk #1 will write 100 chars (remaining 500 bytes, which can fit 83 chars)
+  // chunk #2 will write  83 chars (remaining 417 bytes, which can fit 69 chars)
+  // chunk #3 will write  17 chars and the writing is complete with no checking
+  // nor any unnecessary expansion/copy of the buffer
+  const base::Vector<const SrcChar> vector = string->GetCharVector<SrcChar>(no_gc);
+  int offset = 0;
+  while(offset < vector.length()) {
+    int max_chars = MaxCharsThatFit() - 1; // leave room for trailing "
+    if (max_chars < 1) {
+      Extend();
+      max_chars = MaxCharsThatFit() - 1; // leave room for trailing "
+    }
+    // write at most max_chars unchecked and loop again if buffer space is available
+    max_chars = std::min(max_chars, vector.length() - offset);
+    NoExtendBuilder<DestChar> no_extend(
+      reinterpret_cast<DestChar*>(part_ptr_) + current_index_,
+      &current_index_);
+
+    required_escaping = SerializeStringUncheckedSWAR_<SrcChar, DestChar, raw_json>(
+      vector, &no_extend, offset, offset+max_chars) || required_escaping;
+    offset += max_chars;
+  }
+
+  if (!raw_json) Append<uint8_t, DestChar>('"');
+  return required_escaping;
+}
+
 template <typename SrcChar, typename DestChar, bool raw_json>
 bool JsonStringifier::SerializeString_(Tagged<String> string,
                                        const DisallowGarbageCollection& no_gc) {
@@ -1610,7 +1764,9 @@ bool JsonStringifier::SerializeString(Handle<String> object) {
   auto string = *object;
   if (encoding_ == String::ONE_BYTE_ENCODING) {
     if (String::IsOneByteRepresentationUnderneath(string)) {
-      return SerializeString_<uint8_t, uint8_t, raw_json>(string, no_gc);
+      return  V8_LIKELY(optimize_serialize_str_)
+                ? SerializeStringOptimized_<uint8_t, uint8_t, raw_json>(string, no_gc)
+                : SerializeString_<uint8_t, uint8_t, raw_json>(string, no_gc);
     } else {
       ChangeEncoding();
     }
@@ -1618,6 +1774,7 @@ bool JsonStringifier::SerializeString(Handle<String> object) {
   DCHECK_EQ(encoding_, String::TWO_BYTE_ENCODING);
   if (String::IsOneByteRepresentationUnderneath(string)) {
     return SerializeString_<uint8_t, base::uc16, raw_json>(string, no_gc);
+
   } else {
     return SerializeString_<base::uc16, base::uc16, raw_json>(string, no_gc);
   }
